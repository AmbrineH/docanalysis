# Patch generated by Pyment v0.3.3

--- a/docanalysis\entity_extraction2.py
+++ b/docanalysis\entity_extraction2.py
@@ -32,6 +32,11 @@
 
 
 def install(package):
+    """
+
+    :param package: 
+
+    """
     if hasattr(pip, 'main'):
         pip.main(['install', package])
     else:
@@ -64,10 +69,11 @@
         self.nlp = None
 
     def switch_spacy_versions(self, spacy_type):
-        """Method to toggle between spacy and scispacy 
-
-        Args:
-            spacy_type (string): "spacy" or "scispacy"
+        """Method to toggle between spacy and scispacy
+
+        :param spacy_type: "spacy" or "scispacy"
+        :type spacy_type: string
+
         """
         logging.info(f'Loading {spacy_type}')
         if spacy_type == "scispacy":
@@ -90,8 +96,9 @@
     def dictionary_to_html(self, html_path):
         """Converts dictionary to html
 
-        Args:
-            html_path (string): path to save html
+        :param html_path: path to save html
+        :type html_path: string
+
         """
         list_of_docs = []
         for sentence in self.sentence_dictionary:
@@ -105,6 +112,25 @@
                                      run_pygetpapers=False, make_section=False, removefalse=True,
                                      csv_name=False, make_ami_dict=False, spacy_model=False, html_path=False, synonyms=False, make_json=False, search_html=False, extract_abb=False):
         """logic implementation (Q: how detailed should the description here be?)
+
+        :param corpus_path: 
+        :param terms_xml_path: 
+        :param search_sections: 
+        :param entities: 
+        :param query:  (Default value = None)
+        :param hits:  (Default value = 30)
+        :param run_pygetpapers:  (Default value = False)
+        :param make_section:  (Default value = False)
+        :param removefalse:  (Default value = True)
+        :param csv_name:  (Default value = False)
+        :param make_ami_dict:  (Default value = False)
+        :param spacy_model:  (Default value = False)
+        :param html_path:  (Default value = False)
+        :param synonyms:  (Default value = False)
+        :param make_json:  (Default value = False)
+        :param search_html:  (Default value = False)
+        :param extract_abb:  (Default value = False)
+
         """
 
         self.spacy_model = spacy_model
@@ -186,10 +212,13 @@
     def run_pygetpapers(self, query, hits, output):
         """calls pygetpapers to query EPMC for papers; downloads specified number of papers
 
-        Args:
-            query (str): query to pygetpapers/EPMC
-            hits (int): number of papers to download
-            output (str): name of the folder
+        :param query: query to pygetpapers/EPMC
+        :type query: str
+        :param hits: number of papers to download
+        :type hits: int
+        :param output: name of the folder
+        :type output: str
+
         """
         pygetpapers_call = Pygetpapers()
         pygetpapers_call.run_command(
@@ -197,10 +226,11 @@
         logging.info(f"making CProject {output} with {hits} papers on {query}")
 
     def run_ami_section(self, path):
-        """ Creates sections folder for each paper (CTree); sections papers into front, body, back and floats based on JATS
-
-        Args:
-            path (string): CProject path
+        """Creates sections folder for each paper (CTree); sections papers into front, body, back and floats based on JATS
+
+        :param path: CProject path
+        :type path: string
+
         """
         file_list = glob(os.path.join(
             path, '**', 'fulltext.xml'), recursive=True)
@@ -216,12 +246,13 @@
     def get_glob_for_section(self, path, section_names):
         """globs for xml files in section folder of each CTree
 
-        Args:
-            path (string): CProject path
-            section_names (string): one or more keys (section names) from CONFIG_SECTIONS
-
-        Returns:
-            list: list of globs
+        :param path: CProject path
+        :type path: string
+        :param section_names: one or more keys (section names) from CONFIG_SECTIONS
+        :type section_names: string
+        :returns: list of globs
+        :rtype: list
+
         """
         for section_name in section_names:
             if section_name in self.sections.keys():
@@ -237,11 +268,11 @@
     def make_dict_with_parsed_document(self, document_type="xml"):
         """creates dictionary with parsed xml or html
 
-        Args:
-            document_type (str, optional): type of file fed: xml or html. Defaults to "xml".
-
-        Returns:
-            dict: python dict containing parsed text from xml or html
+        :param document_type: type of file fed: xml or html. Defaults to "xml".
+        :type document_type: str
+        :returns: python dict containing parsed text from xml or html
+        :rtype: dict
+
         """
 
         self.sentence_dictionary = {}
@@ -265,6 +296,15 @@
         return self.sentence_dictionary
 
     def _make_dict_attributes(self, counter, section, section_path, paragraph_text, sentence):
+        """
+
+        :param counter: 
+        :param section: 
+        :param section_path: 
+        :param paragraph_text: 
+        :param sentence: 
+
+        """
         dict_for_sentences = self.sentence_dictionary[counter]
         dict_for_sentences["file_path"] = section_path
         dict_for_sentences["paragraph"] = paragraph_text
@@ -272,13 +312,13 @@
         dict_for_sentences["section"] = section
 
     def read_text_from_path(self, paragraph_path):
-        """ uses ElementTree to read text from xml files
-
-        Args:
-            paragraph_path (string): path to xml file 
-
-        Returns:
-            string: raw text from xml
+        """uses ElementTree to read text from xml files
+
+        :param paragraph_path: path to xml file
+        :type paragraph_path: string
+        :returns: raw text from xml
+        :rtype: string
+
         """
         try:
             tree = ET.parse(paragraph_path)
@@ -294,13 +334,13 @@
         return paragraph_text
 
     def read_text_from_html(self, paragraph_path):
-        """ uses beautifulsoup to read text from html files
-
-        Args:
-            paragraph_path (string): path to html file 
-
-        Returns:
-            string: raw text from html
+        """uses beautifulsoup to read text from html files
+
+        :param paragraph_path: path to html file
+        :type paragraph_path: string
+        :returns: raw text from html
+        :rtype: string
+
         """
         with open(paragraph_path, encoding="utf-8") as f:
             content = f.read()
@@ -310,9 +350,11 @@
     def run_spacy_over_sections(self, dict_with_parsed_xml, entities_names):
         """uses spacy to extract specific Named-Entities from sentences in python dict
 
-        Args:
-            dict_with_parsed_xml (dict): main dict with sentences
-            entities_names (list): list of kinds of Named-Entities that needs to be extacted
+        :param dict_with_parsed_xml: main dict with sentences
+        :type dict_with_parsed_xml: dict
+        :param entities_names: list of kinds of Named-Entities that needs to be extacted
+        :type entities_names: list
+
         """
         self.switch_spacy_versions(self.spacy_model)
         for paragraph in tqdm(dict_with_parsed_xml):
@@ -328,6 +370,16 @@
                                         position_start, abbreviations, abbreviations_longform, abbreviation_start, abbreviation_end)
 
     def _get_entities(self, entities_names, doc, entities, labels, position_end, position_start):
+        """
+
+        :param entities_names: 
+        :param doc: 
+        :param entities: 
+        :param labels: 
+        :param position_end: 
+        :param position_start: 
+
+        """
         for ent in doc.ents:
             if (ent.label_ in entities_names) or (entities_names == ['ALL']):
                 self._add_parsed_entities_to_lists(
@@ -336,8 +388,9 @@
     def abbreviation_search_using_sw(self, dict_with_parsed_xml):
         """Extracts abbreviations from sentences using schwartz_hearst. Credit: Ananya Singha
 
-        Args:
-            dict_with_parsed_xml (dict): main python dictionary with sentences
+        :param dict_with_parsed_xml: main python dictionary with sentences
+        :type dict_with_parsed_xml: dict
+
         """
         for text in dict_with_parsed_xml:
             dict_for_sentence = dict_with_parsed_xml[text]
@@ -350,12 +403,11 @@
     def make_abb_exp_list(self, result_dictionary):
         """make lists of abbreviations and expansions to input into xml dictionary creating method
 
-        Args:
-            result_dictionary (dict): main dictionary that contains sentences and abbreviation dict (abb and expansion)
-
-        Returns:
-            list: all abbreviations 
-            list: all corresponding expansions
+        :param result_dictionary: main dictionary that contains sentences and abbreviation dict (abb and expansion)
+        :type result_dictionary: dict
+        :returns: all abbreviations
+        :rtype: list
+
         """
         list_of_name_lists = []
         list_of_term_lists = []
@@ -370,6 +422,11 @@
         return self._list_of_lists_to_single_list(list_of_name_lists), self._list_of_lists_to_single_list(list_of_term_lists)
 
     def _make_list_from_dict(self, pairs):
+        """
+
+        :param pairs: 
+
+        """
         keys_list = []
         values_list = []
         keys_list.extend(pairs.keys())
@@ -377,15 +434,23 @@
         return keys_list, values_list
 
     def _list_of_lists_to_single_list(self, list_of_lists):
+        """
+
+        :param list_of_lists: 
+
+        """
         return [item for sublist in list_of_lists for item in sublist]
 
     def make_ami_dict_from_abbreviation(self, title, result_dictionary, path):
         """create xml ami-dict containing abbreviations extracted from sentences
 
-        Args:
-            title (str): title of xml ami-dict
-            result_dictionary (dict): main dictionary with sentences and corresponding abbeviations
-            path (str): path where the xml ami-dict file would lie
+        :param title: title of xml ami-dict
+        :type title: str
+        :param result_dictionary: main dictionary with sentences and corresponding abbeviations
+        :type result_dictionary: dict
+        :param path: path where the xml ami-dict file would lie
+        :type path: str
+
         """
         name_list, term_list = self.make_abb_exp_list(result_dictionary)
         dictionary_element = etree.Element("dictionary")
@@ -405,11 +470,25 @@
         logging.info(f'wrote all abbreviations to ami dict {path}.xml')
 
     def _etree_to_string(self, dictionary_element):
+        """
+
+        :param dictionary_element: 
+
+        """
         xml_dict = etree.tostring(
             dictionary_element, pretty_print=True).decode('utf-8')
         return xml_dict
 
     def _get_abbreviations(self, doc, abbreviations, abbreviations_longform, abbreviation_start, abbreviation_end):
+        """
+
+        :param doc: 
+        :param abbreviations: 
+        :param abbreviations_longform: 
+        :param abbreviation_start: 
+        :param abbreviation_end: 
+
+        """
         for abrv in doc._.abbreviations:
             abbreviations.append(abrv)
             abbreviations_longform.append(abrv._.long_form)
@@ -419,10 +498,13 @@
     def add_if_file_contains_terms(self, compiled_terms, dict_with_parsed_xml, searching='has_terms'):
         """populate the main dictionary with term matches, its frequency and span
 
-        Args:
-            compiled_terms (list): list of compiled ami-dict terms
-            dict_with_parsed_xml (dict): dictionary containing sentences
-            searching (str, optional): dict key name. Defaults to 'has_terms'.
+        :param compiled_terms: list of compiled ami-dict terms
+        :type compiled_terms: list
+        :param dict_with_parsed_xml: dictionary containing sentences
+        :type dict_with_parsed_xml: dict
+        :param searching: dict key name. Defaults to 'has_terms'.
+        :type searching: str
+
         """
         for statement in tqdm(dict_with_parsed_xml):
             dict_for_sentence = dict_with_parsed_xml[statement]
@@ -438,14 +520,13 @@
     def search_sentence_with_compiled_terms(self, compiled_terms, sentence):
         """search sentences using the compiled ami-dict entry
 
-        Args:
-            compiled_terms (list): list of compiled ami-dict terms
-            sentence (string): sentence to search using compiled terms
-
-        Returns:
-            list: list of terms that was found after searching sentence
-            list: list of spans corresponding to found terms
-            int: number of term hits
+        :param compiled_terms: list of compiled ami-dict terms
+        :type compiled_terms: list
+        :param sentence: sentence to search using compiled terms
+        :type sentence: string
+        :returns: list of terms that was found after searching sentence
+        :rtype: list
+
         """
         # https://stackoverflow.com/questions/47681756/match-exact-phrase-within-a-string-in-python
         match_list = []
@@ -462,12 +543,11 @@
     def get_terms_from_ami_xml(self, xml_path):
         """parses ami-dict (xml) and reads the entry terms; ami-dict can either be the default ones (user specifies python dict key) or customized ones (user specifies full path to it)
 
-
-        Args:
-            xml_path (string): either keys from dict_of_ami_dict or full path to ami-dict
-
-        Returns:
-            list: list of regex compiled entry terms from ami-dict
+        :param xml_path: either keys from dict_of_ami_dict or full path to ami-dict
+        :type xml_path: string
+        :returns: list of regex compiled entry terms from ami-dict
+        :rtype: list
+
         """
         if xml_path in self.dict_of_ami_dict.keys():
             logging.info(f"getting terms from {xml_path}")
@@ -484,6 +564,11 @@
         return (set(compiled_terms))
 
     def _compiled_regex(self, iterate_over):
+        """
+
+        :param iterate_over: 
+
+        """
         compiled_terms = []
         for para in iterate_over:
             try:
@@ -498,17 +583,21 @@
         return compiled_terms
 
     def _regex_compile(self, term):
+        """
+
+        :param term: 
+
+        """
         return re.compile(r'\b{}\b'.format(term))
 
     def get_synonyms_from_ami_xml(self, xml_path):
         """parses ami-dict (xml) and reads the entry's synonyms; ami-dict can either be the default ones (user specifies python dict key) or customized ones (user specifies full path to it)
 
-
-        Args:
-            xml_path (string): either keys from dict_of_ami_dict or full path to ami-dict
-
-        Returns:
-            list: list of regex compiled entry's synonyms from ami-dict
+        :param xml_path: either keys from dict_of_ami_dict or full path to ami-dict
+        :type xml_path: string
+        :returns: list of regex compiled entry's synonyms from ami-dict
+        :rtype: list
+
         """
         if xml_path in self.dict_of_ami_dict.keys():
             logging.info(f"getting synonyms from {xml_path}")
@@ -524,6 +613,7 @@
         return synonyms
 
     def _make_required_lists(self):
+        """ """
         abbreviations = []
         abbreviations_longform = []
         abbreviation_start = []
@@ -536,6 +626,19 @@
 
     def _add_lists_to_dict(self, dict_for_sentence, entities, labels, position_end,
                            position_start, abbreviations, abbreviations_longform, abbreviation_start, abbreviation_end):
+        """
+
+        :param dict_for_sentence: 
+        :param entities: 
+        :param labels: 
+        :param position_end: 
+        :param position_start: 
+        :param abbreviations: 
+        :param abbreviations_longform: 
+        :param abbreviation_start: 
+        :param abbreviation_end: 
+
+        """
 
         dict_for_sentence['entities'] = entities
         dict_for_sentence['labels'] = labels
@@ -547,6 +650,15 @@
         dict_for_sentence['abbreviation_end'] = abbreviation_end
 
     def _add_parsed_entities_to_lists(self, entities, labels, position_end, position_start, ent=None):
+        """
+
+        :param entities: 
+        :param labels: 
+        :param position_end: 
+        :param position_start: 
+        :param ent:  (Default value = None)
+
+        """
         entities.append(ent.text)
         labels.append(ent.label_)
         position_start.append(ent.start_char)
@@ -555,9 +667,11 @@
     def convert_dict_to_csv(self, path, dict_with_parsed_xml):
         """Turns python dictionary into CSV using pandas
 
-        Args:
-            path (string): CSV file to write output
-            dict_with_parsed_xml (dict): python dictionary that needs to be converted to csv
+        :param path: CSV file to write output
+        :type path: string
+        :param dict_with_parsed_xml: python dictionary that needs to be converted to csv
+        :type dict_with_parsed_xml: dict
+
         """
         df = pd.DataFrame(dict_with_parsed_xml)
         df = df.T
@@ -575,12 +689,13 @@
     def remove_paragraph_form_parsed_xml_dict(self, dict_with_parsed_xml, key_to_remove):
         """pops out the specified key value pairs from python dictionaries
 
-        Args:
-            dict_with_parsed_xml (dict): python dict from which a key-value pair needs to be removed
-            key_to_remove (string): key of the pair that needs to be removed
-
-        Returns:
-            dict: python dict with the specified key-value pair removed
+        :param dict_with_parsed_xml: python dict from which a key-value pair needs to be removed
+        :type dict_with_parsed_xml: dict
+        :param key_to_remove: key of the pair that needs to be removed
+        :type key_to_remove: string
+        :returns: python dict with the specified key-value pair removed
+        :rtype: dict
+
         """
         for entry in dict_with_parsed_xml:
             dict_with_parsed_xml[entry].pop(key_to_remove, None)
@@ -589,9 +704,11 @@
     def convert_dict_to_json(self, path, dict_with_parsed_xml):
         """writes python dictionary to json file
 
-        Args:
-            path (str): json file path to write to
-            dict_with_parsed_xml (dict): main dictionary with sentences, search hits, entities, etc.
+        :param path: json file path to write to
+        :type path: str
+        :param dict_with_parsed_xml: main dictionary with sentences, search hits, entities, etc.
+        :type dict_with_parsed_xml: dict
+
         """
         with open(path, mode='w', encoding='utf-8') as f:
             json.dump(dict_with_parsed_xml, f, indent=4)
@@ -600,9 +717,11 @@
     def remove_statements_not_having_xmldict_terms(self, dict_with_parsed_xml, searching='has_terms'):
         """removes key-value pairs from the main python dict that do not have any match hits
 
-        Args:
-            dict_with_parsed_xml (dict): python dictionary from which the specific key-value pairs needs to be removed
-            searching (str, optional): the key to the pair in the nested-dict that needs to be removed 
+        :param dict_with_parsed_xml: python dictionary from which the specific key-value pairs needs to be removed
+        :type dict_with_parsed_xml: dict
+        :param searching: the key to the pair in the nested-dict that needs to be removed (Default value = 'has_terms')
+        :type searching: str
+
         """
         statement_to_pop = []
         for statement in dict_with_parsed_xml:
@@ -614,14 +733,15 @@
             dict_with_parsed_xml.pop(term)
 
     def make_ami_dict_from_list(self, list_of_terms_with_count, title):
-        """makes ami-dict from a python dictionary containing terms and frequencies. 
-
-        Args:
-            list_of_terms_with_count (dict): python dictionary containing terms and their frequency of occurence
-            title (string): title of the xml ami-dict as well as the name of the XML file
-
-        Returns:
-            file: xml ami-dict
+        """makes ami-dict from a python dictionary containing terms and frequencies.
+
+        :param list_of_terms_with_count: python dictionary containing terms and their frequency of occurence
+        :type list_of_terms_with_count: dict
+        :param title: title of the xml ami-dict as well as the name of the XML file
+        :type title: string
+        :returns: xml ami-dict
+        :rtype: file
+
         """
         dictionary_element = etree.Element("dictionary")
         dictionary_element.attrib['title'] = title
@@ -635,16 +755,25 @@
         return self._etree_to_string(dictionary_element)
 
     def _write_string_to_file(self, string_to_put, title):
+        """
+
+        :param string_to_put: 
+        :param title: 
+
+        """
         with open(title, mode='w', encoding='utf-8') as f:
             f.write(string_to_put)
 
     def handle_ami_dict_creation(self, result_dictionary, title, path):
-        """creates and writes ami dictionary with entities extracted and their frequency. 
-
-        Args:
-            result_dictionary (dict): main python dictionary with sentences, entities, etc.
-            title (str): title of ami-dictionary (xml file)
-            path (str): file path
+        """creates and writes ami dictionary with entities extracted and their frequency.
+
+        :param result_dictionary: main python dictionary with sentences, entities, etc.
+        :type result_dictionary: dict
+        :param title: title of ami-dictionary (xml file)
+        :type title: str
+        :param path: file path
+        :type path: str
+
         """
         list_of_entities = []
         for entry in result_dictionary:
@@ -661,11 +790,11 @@
     def json_to_dict(self, json_file_link):
         """loads json file as python dictionary
 
-        Args:
-            json_file_link (str): link to json file on the web
-
-        Returns:
-            dictionary: python dictionary from json
+        :param json_file_link: link to json file on the web
+        :type json_file_link: str
+        :returns: python dictionary from json
+        :rtype: dictionary
+
         """
         path = urlopen(json_file_link)
         json_dict = json.load(path)
@@ -674,11 +803,11 @@
     def wiki_lookup(self, query):
         """Queries Wikidata API for Wikidata Item IDs for terms in ami-dict
 
-        Args:
-            query (string): term to query wikdiata for ID
-
-        Returns:
-            list: potential Wikidata Item URLs
+        :param query: term to query wikdiata for ID
+        :type query: string
+        :returns: potential Wikidata Item URLs
+        :rtype: list
+
         """
         params = {
             "action": "wbsearchentities",
